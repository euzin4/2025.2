-dbeavear    //tipo o pgadmin

-DISTINCT, elimina duplicatas no resultado do select:
select distinct col_tabela from nome_tabela 

-o 'IN' funciona como um 'OR':
SELECT * FROM clientes WHERE estado_civil IN (‘Solteiro’, ‘Divorciado’)

-o UNION funciona como um DISTINCT em questao de desempenho

-ALL(retorna somente o filtrado e nao o resto) e ANY(retorna todos exceto o filtrado), usado com operadores >, >=, <, <=, <>, =

-ORDER BY e GROUP BY

-EXISTS
/* EX: buscar clientes que nunca fizeram locaçao */
select * from clientes c where not exists (select * from locacoes l where l.cpf = c.cpf); /* retorna os clientes que nao possuem o cpf na tabela de locaçoes */

-VIEW, deixa fixa a otimização da consulta cadastrada, mas como o banco é dinamico, são poucos os casos em que seu uso é recomendado:
create view nome_view as CONSULTA;
create view teste as select * from minha_tabela;

-view materialized 'pesquisar(importante)', uso em questoes de segurança, diferente da view normal a view materializada salva o resultado da consulta em um lugar separado no banco(tipo um cache)

-indices (index)

-case

-coalesce: retorna o primeiro valor não nulo de uma lista

-concatenar string: usando pipe '||' e concat(), EX: 'exemplo'||valor||'de concatenaçao' , concat(val1,val2,...)
-substituir string: replace('abcdefgcdgh','cd','XX')=abXXefgXXgh

-mostra quem está conectado ao banco e oque esta fazendo, 'select * from pg_stat_activity'

-cte: É um conjunto de resultados temporário e nomeado que você pode referenciar em uma instrução SQL como SELECT, INSERT, UPDATE ou DELETE. Pense na CTE como uma tabela virtual, que só existe durante a execução de uma única consulta.
sintaxe basica:
WITH nome_da_cte (coluna1, coluna2, ...) AS (
    -- A consulta que define o conjunto de resultados da CTE
    SELECT coluna1, coluna2, ...
    FROM tabela
    WHERE ...
)
-- A consulta principal que usa a CTE
SELECT *
FROM nome_da_cte
WHERE ...;

exemplo: Imagine que você quer encontrar os 3 funcionários mais bem pagos em cada departamento.
WITH ranked_salarios AS (
    SELECT
        nome_funcionario,
        salario,
        departamento,
        ROW_NUMBER() OVER(PARTITION BY departamento ORDER BY salario DESC) AS rank
    FROM funcionarios
)
SELECT
    nome_funcionario,
    salario,
    departamento
FROM ranked_salarios
WHERE rank <= 3;


-funçoes: podem ser procedures ou functions, um retorna algo o outro só executa sem retorno

02/10/25
-banco de dados distribuidos:
bancos sincronos e assincronos
o ACID é o maior problema de sistemas sincronos ja que a sincronia\conexao entre os servidores normalmente é o gargalo do sistema
+consultas olap e oltp

06/10/25
-window function
exemplo: 
select *
    , max(c.num_filhos) over (t)
    , avg(c.num_filhos) over (t)
    , rank() over (order by c.num_filhos desc, nome)
from clientes c 
window t as (partition by c.estado_civil);

09/10/25
-continuação banco de dados distribuidos
-big data
#teorema CAP(erik brewer). consistency, availability, partitioning.
-ACID é pra BD relacional, CAP é pra BD NoSQL (acho)

13/10/25
-sistemas NoSQL
exemplos: redis(modelo chave-valor), cassandra(orientado a colunas, usa linguagem propria(CQL)), mongo, neo4j, voldemort, couchDB
-diferente dos bancos relacionais que tem um padrao de funcionamento, os bancos NoSQL funcionam cada um da sua proria forma e com linguagens diferentes
-BD NoSQL não é recomendado se for necessario o uso de relacionamento(join) entre dados
-existem modelos chave-valor, orientado a colunas, orientado a documentos, orientado a grafos

23/10/25
#bancos relacionais se adaptam para varios propositos, ja nos NoSql existem bancos especificos para objetivos especificos, dentre eles existem:
-modelo orientado a documentos
+pesquisar OLTP e OLAP
-modelo orientado a coluna
-modelo orientado a agregados
-modelo orientado a grafos
-BD chave-valor

30/10/25
-mais sobre modelos orientados a chave-valor e coluna

13/11/25
#BDs orientados a documentos
-podem ter formato XML,JSON,BSON,entre outros
-DOM x SAX
-DOM le os dados de um arquivo e monta em formato de arvore, é bom para arquivos pequenos ja que todo o arquivo tem que sem armazenado na memoria
-SAX le os dados sequencialmente linha a linha, é bom para grandes arquivos ja que pode carregar os dados parcialmente na memoria
-instalar mongo com docker(light VM): "sudo apt install docker.io", "sudo docker run --name mongo -d mongo", "sudo docker exec -it mongo bash"
