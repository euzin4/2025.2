-dbeavear    //tipo o pgadmin

-DISTINCT, elimina duplicatas no resultado do select:
select distinct col_tabela from nome_tabela 

-o 'IN' funciona como um 'OR':
SELECT * FROM clientes WHERE estado_civil IN (‘Solteiro’, ‘Divorciado’)

-o UNION funciona como um DISTINCT em questao de desempenho

-ALL(retorna somente o filtrado e nao o resto) e ANY(retorna todos exceto o filtrado), usado com operadores >, >=, <, <=, <>, =

-ORDER BY e GROUP BY

-EXISTS
/* EX: buscar clientes que nunca fizeram locaçao */
select * from clientes c where not exists (select * from locacoes l where l.cpf = c.cpf); /* retorna os clientes que nao possuem o cpf na tabela de locaçoes */

-VIEW, deixa fixa a otimização da consulta cadastrada, mas como o banco é dinamico, são poucos os casos em que seu uso é recomendado:
create view nome_view as CONSULTA;
create view teste as select * from minha_tabela;

-view materialized 'pesquisar(importante)', uso em questoes de segurança, diferente da view normal a view materializada salva o resultado da consulta em um lugar separado no banco(tipo um cache)

-indices (index)

-case

-coalesce: retorna o primeiro valor não nulo de uma lista

-concatenar string: usando pipe '||' e concat(), EX: 'exemplo'||valor||'de concatenaçao' , concat(val1,val2,...)
-substituir string: replace('abcdefgcdgh','cd','XX')=abXXefgXXgh

-mostra quem está conectado ao banco e oque esta fazendo, 'select * from pg_stat_activity'

-cte: É um conjunto de resultados temporário e nomeado que você pode referenciar em uma instrução SQL como SELECT, INSERT, UPDATE ou DELETE. Pense na CTE como uma tabela virtual, que só existe durante a execução de uma única consulta.
sintaxe basica:
WITH nome_da_cte (coluna1, coluna2, ...) AS (
    -- A consulta que define o conjunto de resultados da CTE
    SELECT coluna1, coluna2, ...
    FROM tabela
    WHERE ...
)
-- A consulta principal que usa a CTE
SELECT *
FROM nome_da_cte
WHERE ...;

exemplo: Imagine que você quer encontrar os 3 funcionários mais bem pagos em cada departamento.
WITH ranked_salarios AS (
    SELECT
        nome_funcionario,
        salario,
        departamento,
        ROW_NUMBER() OVER(PARTITION BY departamento ORDER BY salario DESC) AS rank
    FROM funcionarios
)
SELECT
    nome_funcionario,
    salario,
    departamento
FROM ranked_salarios
WHERE rank <= 3;


-funçoes: podem ser procedures ou functions, um retorna algo o outro só executa sem retorno

02/10/25
-banco de dados distribuidos:
bancos sincronos e assincronos
o ACID é o maior problema de sistemas sincronos ja que a sincronia\conexao entre os servidores normalmente é o gargalo do sistema
+consultas olap e oltp

06/10/25
-window function
exemplo: 
select *
    , max(c.num_filhos) over (t)
    , avg(c.num_filhos) over (t)
    , rank() over (order by c.num_filhos desc, nome)
from clientes c 
window t as (partition by c.estado_civil);

09/10/25
-continuação banco de dados distribuidos
-big data
-teorema CAP(erik brewer). consistency, availability, partitioning.
